# Proper Pixel Art

## Summary

- Converts noisy, high resolution pixel-art-style images such as those produced by generative models to true pixel resolution assets.

- Clean screenshots or low-quality web uploads of sprites.

## Installation

### Clone the Repository:

```bash
git clone git@github.com:KennethJAllen/proper-pixel-art.git
cd proper-pixel-art
```

### Create Virtual Environment

- Install [uv](https://docs.astral.sh/uv/getting-started/installation/) if not already installed.
- Sync environments
  - `uv sync`

## Usage

First, obtain a source pixel-art-style image (e.g. a pixel-art-style image generated by GPT-4o or a screenshot of pixel-art).

### CLI

```bash
uv run ppa <input_path> -o <output_path> -c <num_colors> -s <result_scale> [-t]
# or directly using uvx
uvx --from https://github.com/KennethJAllen/proper-pixel-art.git ppa <input_path> -o <output_path> -c <num_colors> -s <result_scale> [-t]
```

#### Flags

| Flag                             | Description                                                                                               |
| -------------------------------- | --------------------------------------------------------------------------------------------------------- |
| INPUT (positional)        | Source file in pixel-art-style                                                                      |
| `-o`, `--output` `<path>`        | Output directory or file path for result. (default: '.')                                                  |
| `-c`, `--colors` `<int>`         | Number of colors for output. May need to try a few different values. (default 16)                         |
| `-s`, `--scale-result` `<int>`     | Width/height of each "pixel" in the output. (default: 1)                                                          |
| `-t`, `--transparent` `<bool>`   | Output with transparent background. (default: off)                                                        |
| `-u`, `--initial-upscale` `<int>` | Initial image upscale factor. Increasing this may help detect pixel edges. (default 2)                    |
| `-w`, `--pixel-width` `<int>`    | Width of the pixels in the input image. If not set, it will be determined automatically. (default: None)  |
| `--threshold` `<float>`          | Color distance threshold for auto-colors (LAB Delta E). (default: 5.0)                                    |
| `--center-ratio` `<float>`       | Sample center portion of cells (0.5-1.0). (default: 0.5)                                                  |
| `--no-downsample-first`          | Quantize then downsample (original behavior).                                                             |
| `--no-cluster`                   | Use PIL quantization instead of LAB clustering.                                                           |
| `--no-auto-colors`               | Use fixed color count (`-c`) instead of auto-detection.                                                   |

#### Example

`uv run ppa assets/blob/blob.png -c 16 -s 20 -t`

### Python

#### Simple Example

```python
from PIL import Image
from proper_pixel_art.pixelate import pixelate

image = Image.open('input.png')
result = pixelate(image, num_colors=16)
result.save('output.png')
```

#### Parameters

- `image` : `PIL.Image.Image`

  - A PIL image to pixelate.

- `num_colors` : `int`

  - The number of colors in result.
  - May need to try a few values if the colors don't look right.
  - 8, 16, 32, or 64 typically works.

- `initial_upscale` : `int`

  - Upscale result after algorithm is complete if not None.

- `scale_result` : `int`

  - Upscale initial image. This may help detect lines.

- `transparent_background` : `bool`
  - If True, flood fills each corner of the result with transparent alpha.

- `intermediate_dir` : `Path | None`
  - Directory to save images visualizing intermediate steps of algorithm. Useful for development.

- `pixel_width` : `int | None`
  - Width of the pixels in the input image. If not set, it will be determined automatically. It may be helpful to increase this parameter if not enough pixel edges are being detected.

- `downsample_first` : `bool`
  - If True, downsample then quantize (better color consistency). If False, quantize then downsample (original algorithm). Default: False in API, True in CLI.

- `quantizer` : `Callable[[Image], Image] | None`
  - Custom quantization function. If None, uses PIL quantization. See `quantize_cluster` in `proper_pixel_art.quantize` for LAB-space clustering with auto color detection.

- `center_ratio` : `float`
  - Sample center portion of cells (0.5-1.0). Reduces edge noise. Default: 0.5.

#### Returns

A PIL image with true pixel resolution and quantized colors. 

## Examples

The algorithm is robust. It performs well for images that are already approximately alligned to a grid.

Here are a few examples. A mesh is computed, where each cell corresponds to one pixel.

### Bat

- Generated by GPT-4o.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/bat/bat.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/bat/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/bat/result.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

### Ash

- Screenshot from Google images of Pokemon asset.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/ash/ash.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/ash/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/ash/result.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

### Demon

- Original image generated by GPT-4o.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/demon/demon.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/demon/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/demon/result.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

### Pumpkin

- Screenshot from Google Images of Stardew Valley asset. This is an adversarial example as the source image is both low quality and the object is round.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/pumpkin/pumpkin.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/pumpkin/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/pumpkin/result.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

## Real Images To Pixel Art

- This tool can also be used to convert real images to pixel art by first requesting a pixelated version of the original image from GPT-4o, then using the tool to get the true pixel-resolution image.

- Consider this image of a mountain

<img src="./assets/mountain/real.jpg" width="50%" alt="Original mountain"/>

- Here are the results of first requesting a pixelated version of the mountain, then using the tool to get a true resolution pixel art version.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/mountain/mountain.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/mountain/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/mountain/result.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

## Challenges

The result of pixel-art style images from LLMs are noisy, high resolution images with a non-uniform grid and random artifacts. Due to these issues, standard downsampling techniques do not work. How can we recover the pixel art with "true" resolution and colors?

The current approach to turning pixel art into useable assets for games are either

1) Use naive downsampling which does not give a result that is faithful to the original image.
2) Manually re-create the image in the appropriate resolution pixel by pixel.

## Algorithm

- The main algorithm solves these challenges. Here is a high level overview. We will apply it step by step on this example image of blob pixel art that was generated from GPT-4o.

<img src="./assets/blob/blob.png" width="80%" alt="blob"/>

- Note that this image is high resolution and noisy.

<img src="./assets/blob/zoom.png" width="80%" alt="The blob is noisy."/>

1) Trim the edges of the image and zero out pixels with more than 50% alpha.
    - This is to work around some issues with models such as GPT-4o not giving a perfectly transparent background.

2) Upscale by a factor of 2 using nearest neighbor.
    - This can help identify the correct pixel mesh.

3) Find edges of the pixel art using [Canny edge detection](https://docs.opencv.org/4.x/da/d22/tutorial_py_canny.html).

<img src="./assets/blob/edges.png" width="80%" alt="blob edges"/>

4) Close small gaps in edges with a [morphological closing](https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html).

<img src="./assets/blob/closed_edges.png" width="80%" alt="blob closed edges"/>

5) Take the [probabalistic Hough transform](https://docs.opencv.org/4.x/d3/de6/tutorial_js_houghlines.html) to get the coordinates of lines in the detected edges. Only keep lines that are close to vertical or horizontal giving some grid coordinates. Cluster lines that are closeby together.

<img src="./assets/blob/lines.png" width="80%" alt="blob lines"/>

6) Find the grid spacing by filtering outliers and taking the median of the spacings, then complete the mesh.

<img src="./assets/blob/mesh.png" width="80%" alt="blob mesh"/>

7) In each cell specified by the mesh, choose the most common color in the cell's center region as the color for the pixel. Recreate the original image with one pixel per cell.

8) Quantize colors using LAB-space hierarchical clustering with auto-detected color count.
    - LAB space ensures perceptually uniform color distances.
    - Similar colors (within threshold) are merged to eliminate noise.
    - The most frequent original color in each cluster is used (no "compromise colors").
    - For original behavior (quantize first, then downsample), use `--no-downsample-first --no-cluster --no-auto-colors -c <num_colors>`.

    - Result upscaled by a factor of $20 \times$ using nearest neighbor.

<img src="./assets/blob/result.png" width="80%" alt="blob pixelated"/>

## Testing

To test algorithm changes and verify output quality:

```bash
uv run pytest -s
```

The tests pixelate all assets in `assets/{name}/{name}.png` and save outputs to `tests/outputs/` for manual visual inspection.
